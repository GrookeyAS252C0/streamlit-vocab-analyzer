#!/usr/bin/env python3
"""
ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
åˆ†æçµæœã‚’æ§˜ã€…ãªå½¢å¼ã§å‡ºåŠ›
"""

import json
import logging
from typing import Dict, List, Optional
from pathlib import Path
import datetime
from dataclasses import dataclass
import pandas as pd

logger = logging.getLogger(__name__)

@dataclass
class ReportConfig:
    """ãƒ¬ãƒãƒ¼ãƒˆè¨­å®š"""
    title: str = "ReadingAssist Analysis Report"
    author: str = "ReadingAssist Analyzer"
    include_charts: bool = True
    include_raw_data: bool = False
    format: str = "html"  # html, json, csv, txt

class ReportGenerator:
    """ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, config: ReportConfig = None):
        """
        åˆæœŸåŒ–
        
        Args:
            config: ãƒ¬ãƒãƒ¼ãƒˆè¨­å®š
        """
        self.config = config or ReportConfig()
    
    def generate_comprehensive_report(
        self, 
        analysis_result: Dict, 
        output_path: str
    ) -> bool:
        """
        ç·åˆåˆ†æãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
        
        Args:
            analysis_result: åˆ†æçµæœ
            output_path: å‡ºåŠ›ãƒ‘ã‚¹
            
        Returns:
            ç”ŸæˆæˆåŠŸãƒ•ãƒ©ã‚°
        """
        try:
            output_path = Path(output_path)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            
            if self.config.format == "html":
                return self._generate_html_report(analysis_result, output_path)
            elif self.config.format == "json":
                return self._generate_json_report(analysis_result, output_path)
            elif self.config.format == "csv":
                return self._generate_csv_report(analysis_result, output_path)
            elif self.config.format == "txt":
                return self._generate_text_report(analysis_result, output_path)
            else:
                logger.error(f"ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å½¢å¼: {self.config.format}")
                return False
                
        except Exception as e:
            logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    def _generate_html_report(self, analysis_result: Dict, output_path: Path) -> bool:
        """HTMLãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ"""
        try:
            html_content = self._create_html_template(analysis_result)
            
            with open(output_path.with_suffix('.html'), 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            logger.info(f"HTMLãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆã—ã¾ã—ãŸ: {output_path.with_suffix('.html')}")
            return True
            
        except Exception as e:
            logger.error(f"HTMLãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    def _create_html_template(self, analysis_result: Dict) -> str:
        """HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ä½œæˆ"""
        
        # åŸºæœ¬æƒ…å ±ã®å–å¾—
        metadata = analysis_result.get('metadata', {})
        assessment = analysis_result.get('comprehensive_assessment', {})
        report = analysis_result.get('integrated_report', {})
        
        timestamp = metadata.get('analysis_timestamp', datetime.datetime.now().isoformat())
        
        html_content = f"""
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{self.config.title}</title>
    <style>
        {self._get_css_styles()}
    </style>
</head>
<body>
    <div class="container">
        <header class="report-header">
            <h1>ğŸ“š {self.config.title}</h1>
            <p class="subtitle">è‹±æ–‡èª­è§£ã«ãŠã‘ã‚‹ç·åˆåˆ†æãƒ¬ãƒãƒ¼ãƒˆ</p>
            <div class="metadata">
                <p><strong>ç”Ÿæˆæ—¥æ™‚:</strong> {timestamp}</p>
                <p><strong>ä½œæˆè€…:</strong> {self.config.author}</p>
            </div>
        </header>
        
        <main>
            {self._create_executive_summary_section(assessment, report)}
            {self._create_detailed_analysis_section(analysis_result)}
            {self._create_recommendations_section(report)}
            {self._create_action_plan_section(report)}
        </main>
        
        <footer class="report-footer">
            <p>Generated by ReadingAssist Analyzer v1.0.0</p>
        </footer>
    </div>
</body>
</html>
"""
        return html_content
    
    def _get_css_styles(self) -> str:
        """CSSã‚¹ã‚¿ã‚¤ãƒ«ã®å–å¾—"""
        return """
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        
        .container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .report-header {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .report-header h1 {
            margin: 0 0 10px 0;
            font-size: 2.5em;
        }
        
        .subtitle {
            font-size: 1.2em;
            margin: 10px 0;
            opacity: 0.9;
        }
        
        .metadata {
            margin-top: 20px;
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        main {
            padding: 30px;
        }
        
        .section {
            margin-bottom: 40px;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
            background: #f8f9fa;
        }
        
        .section h2 {
            color: #2c3e50;
            margin-top: 0;
            font-size: 1.8em;
        }
        
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .metric-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #4CAF50;
            margin: 10px 0;
        }
        
        .metric-label {
            color: #666;
            font-size: 0.9em;
        }
        
        .challenge-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        
        .recommendation-box {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .data-table th,
        .data-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        .data-table th {
            background: #4CAF50;
            color: white;
        }
        
        .data-table tr:nth-child(even) {
            background: #f2f2f2;
        }
        
        .report-footer {
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 20px;
            font-size: 0.9em;
        }
        
        ul.recommendation-list {
            list-style-type: none;
            padding: 0;
        }
        
        ul.recommendation-list li {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 4px;
            border-left: 3px solid #4CAF50;
        }
        
        .highlight {
            background: #fff176;
            padding: 2px 4px;
            border-radius: 2px;
        }
        """
    
    def _create_executive_summary_section(self, assessment: Dict, report: Dict) -> str:
        """ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ä½œæˆ"""
        executive_summary = report.get('executive_summary', {})
        
        return f"""
        <section class="section">
            <h2>ğŸ“Š ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼</h2>
            <div class="metric-grid">
                <div class="metric-card">
                    <div class="metric-label">ç·åˆé›£æ˜“åº¦</div>
                    <div class="metric-value">{assessment.get('difficulty_level', 'ä¸æ˜')}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">èª­è§£ãƒ¬ãƒ™ãƒ«</div>
                    <div class="metric-value">{assessment.get('reading_level', 'ä¸æ˜')}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">æ¨å®šèª­è§£æ™‚é–“</div>
                    <div class="metric-value">{assessment.get('estimated_reading_time_minutes', 0)}åˆ†</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">ç·åˆã‚¹ã‚³ã‚¢</div>
                    <div class="metric-value">{assessment.get('overall_difficulty_score', 0):.1f}</div>
                </div>
            </div>
            
            <h3>âš ï¸ ä¸»è¦ãªå­¦ç¿’èª²é¡Œ</h3>
            {self._format_challenges(executive_summary.get('key_challenges', []))}
        </section>
        """
    
    def _create_detailed_analysis_section(self, analysis_result: Dict) -> str:
        """è©³ç´°åˆ†æã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ä½œæˆ"""
        vocab_analysis = analysis_result.get('vocabulary_analysis', {})
        grammar_analysis = analysis_result.get('grammar_analysis', {})
        sentence_analysis = analysis_result.get('sentence_analysis', {})
        
        return f"""
        <section class="section">
            <h2>ğŸ” è©³ç´°åˆ†æçµæœ</h2>
            
            {self._create_vocabulary_subsection(vocab_analysis)}
            {self._create_grammar_subsection(grammar_analysis)}
            {self._create_sentence_subsection(sentence_analysis)}
        </section>
        """
    
    def _create_vocabulary_subsection(self, vocab_analysis: Dict) -> str:
        """èªå½™åˆ†æã‚µãƒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³"""
        if not vocab_analysis:
            return "<h3>ğŸ“š èªå½™åˆ†æ</h3><p>èªå½™åˆ†æãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>"
        
        summary = vocab_analysis.get('summary', {})
        coverage = vocab_analysis.get('vocabulary_coverage', {})
        
        # å˜èªå¸³ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ†ãƒ¼ãƒ–ãƒ«
        coverage_table = "<table class='data-table'><thead><tr><th>å˜èªå¸³</th><th>èªå½™ã‚«ãƒãƒ¬ãƒƒã‚¸ç‡(%)</th><th>å˜èªå¸³ä½¿ç”¨ç‡(%)</th><th>ä¸€è‡´èªæ•°</th></tr></thead><tbody>"
        
        for book_name, data in coverage.items():
            coverage_table += f"""
            <tr>
                <td>{book_name}</td>
                <td>{data.get('vocabulary_coverage_rate', 0):.1f}%</td>
                <td>{data.get('vocabulary_utilization_rate', 0):.1f}%</td>
                <td>{data.get('matched_words_count', 0):,}</td>
            </tr>
            """
        
        coverage_table += "</tbody></table>"
        
        return f"""
        <h3>ğŸ“š èªå½™åˆ†æ</h3>
        <div class="metric-grid">
            <div class="metric-card">
                <div class="metric-label">æŠ½å‡ºç·å˜èªæ•°</div>
                <div class="metric-value">{vocab_analysis.get('text_statistics', {}).get('total_words', 0):,}</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">ãƒ¦ãƒ‹ãƒ¼ã‚¯å˜èªæ•°</div>
                <div class="metric-value">{vocab_analysis.get('text_statistics', {}).get('unique_words', 0):,}</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">æœ€é©å˜èªå¸³</div>
                <div class="metric-value">{summary.get('best_coverage_book', {}).get('name', 'ä¸æ˜')}</div>
            </div>
        </div>
        
        <h4>å˜èªå¸³åˆ¥ã‚«ãƒãƒ¬ãƒƒã‚¸</h4>
        {coverage_table}
        """
    
    def _create_grammar_subsection(self, grammar_analysis: Dict) -> str:
        """æ–‡æ³•åˆ†æã‚µãƒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³"""
        if not grammar_analysis:
            return "<h3>ğŸ“ æ–‡æ³•åˆ†æ</h3><p>æ–‡æ³•åˆ†æãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>"
        
        summary = grammar_analysis.get('summary', {})
        grammar_items = grammar_analysis.get('grammar_items', {})
        
        # æ–‡æ³•é …ç›®ãƒ†ãƒ¼ãƒ–ãƒ«
        grammar_table = "<table class='data-table'><thead><tr><th>æ–‡æ³•é …ç›®</th><th>å‡ºç¾å›æ•°</th><th>é »åº¦(/100èª)</th><th>é›£æ˜“åº¦</th></tr></thead><tbody>"
        
        for name, data in grammar_items.items():
            if data.get('count', 0) > 0:
                grammar_table += f"""
                <tr>
                    <td>{name}</td>
                    <td>{data.get('count', 0)}</td>
                    <td>{data.get('frequency_per_100_words', 0):.2f}</td>
                    <td>{data.get('difficulty_level', 'basic')}</td>
                </tr>
                """
        
        grammar_table += "</tbody></table>"
        
        return f"""
        <h3>ğŸ“ æ–‡æ³•åˆ†æ</h3>
        <div class="metric-grid">
            <div class="metric-card">
                <div class="metric-label">æ–‡æ³•é …ç›®æ•°</div>
                <div class="metric-value">{summary.get('total_grammar_items', 0)}</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">æ–‡æ³•å¯†åº¦</div>
                <div class="metric-value">{summary.get('grammar_density', 0):.1f}%</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">è¤‡é›‘åº¦ãƒ¬ãƒ™ãƒ«</div>
                <div class="metric-value">{summary.get('complexity_level', 'ä¸æ˜')}</div>
            </div>
        </div>
        
        <h4>æ–‡æ³•é …ç›®å‡ºç¾çŠ¶æ³</h4>
        {grammar_table}
        """
    
    def _create_sentence_subsection(self, sentence_analysis: Dict) -> str:
        """æ–‡æ§‹é€ åˆ†æã‚µãƒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³"""
        if not sentence_analysis:
            return "<h3>ğŸ”— æ–‡æ§‹é€ åˆ†æ</h3><p>æ–‡æ§‹é€ åˆ†æãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>"
        
        basic_stats = sentence_analysis.get('basic_statistics', {})
        complexity = sentence_analysis.get('complexity_analysis', {})
        readability = sentence_analysis.get('readability_scores', {})
        
        return f"""
        <h3>ğŸ”— æ–‡æ§‹é€ åˆ†æ</h3>
        <div class="metric-grid">
            <div class="metric-card">
                <div class="metric-label">ç·æ–‡æ•°</div>
                <div class="metric-value">{basic_stats.get('total_sentences', 0)}</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">å¹³å‡æ–‡é•·</div>
                <div class="metric-value">{basic_stats.get('avg_words_per_sentence', 0):.1f}èª</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">è¤‡é›‘åº¦</div>
                <div class="metric-value">{complexity.get('complexity_level', 'ä¸æ˜')}</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">èª­ã¿ã‚„ã™ã•</div>
                <div class="metric-value">{readability.get('reading_level', 'ä¸æ˜')}</div>
            </div>
        </div>
        """
    
    def _create_recommendations_section(self, report: Dict) -> str:
        """æ¨å¥¨äº‹é …ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ä½œæˆ"""
        study_recommendations = report.get('study_recommendations', {})
        
        if not study_recommendations:
            return "<section class='section'><h2>ğŸ’¡ å­¦ç¿’æ¨å¥¨äº‹é …</h2><p>æ¨å¥¨äº‹é …ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p></section>"
        
        sections = ""
        
        for area, recommendations in study_recommendations.items():
            if recommendations:
                area_name = {
                    'priority_areas': 'å„ªå…ˆå­¦ç¿’åˆ†é‡',
                    'vocabulary_study': 'èªå½™å­¦ç¿’',
                    'grammar_study': 'æ–‡æ³•å­¦ç¿’',
                    'reading_strategy': 'èª­è§£æˆ¦ç•¥'
                }.get(area, area)
                
                sections += f"""
                <h3>{area_name}</h3>
                <ul class="recommendation-list">
                """
                
                for rec in recommendations:
                    sections += f"<li>{rec}</li>"
                
                sections += "</ul>"
        
        return f"""
        <section class="section">
            <h2>ğŸ’¡ å­¦ç¿’æ¨å¥¨äº‹é …</h2>
            {sections}
        </section>
        """
    
    def _create_action_plan_section(self, report: Dict) -> str:
        """ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ©ãƒ³ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ä½œæˆ"""
        action_plan = report.get('action_plan', {})
        
        if not action_plan:
            return "<section class='section'><h2>ğŸ¯ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ©ãƒ³</h2><p>ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ©ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p></section>"
        
        schedule = action_plan.get('study_schedule', {})
        immediate_actions = action_plan.get('immediate_actions', [])
        
        return f"""
        <section class="section">
            <h2>ğŸ¯ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ©ãƒ³</h2>
            
            <h3>ğŸ“… å­¦ç¿’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«</h3>
            <div class="metric-grid">
                <div class="metric-card">
                    <div class="metric-label">æ¨å¥¨å­¦ç¿’æœŸé–“</div>
                    <div class="metric-value">{schedule.get('recommended_study_period', 'ä¸æ˜')}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">1æ—¥ã®å­¦ç¿’æ™‚é–“</div>
                    <div class="metric-value">{schedule.get('daily_study_time', 'ä¸æ˜')}</div>
                </div>
            </div>
            
            <h3>âš¡ å³åº§ã«å–ã‚Šçµ„ã‚€ã¹ãé …ç›®</h3>
            <ul class="recommendation-list">
            {''.join(f'<li>{action}</li>' for action in immediate_actions)}
            </ul>
        </section>
        """
    
    def _format_challenges(self, challenges: List[str]) -> str:
        """èª²é¡Œãƒªã‚¹ãƒˆã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        if not challenges:
            return "<p>ç‰¹ã«å¤§ããªèª²é¡Œã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚</p>"
        
        formatted = ""
        for challenge in challenges:
            formatted += f'<div class="challenge-box">{challenge}</div>'
        
        return formatted
    
    def _generate_json_report(self, analysis_result: Dict, output_path: Path) -> bool:
        """JSONãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ"""
        try:
            with open(output_path.with_suffix('.json'), 'w', encoding='utf-8') as f:
                json.dump(analysis_result, f, ensure_ascii=False, indent=2)
            
            logger.info(f"JSONãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆã—ã¾ã—ãŸ: {output_path.with_suffix('.json')}")
            return True
            
        except Exception as e:
            logger.error(f"JSONãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    def _generate_csv_report(self, analysis_result: Dict, output_path: Path) -> bool:
        """CSVãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ"""
        try:
            # èªå½™åˆ†æçµæœã‚’CSVã«å¤‰æ›
            vocab_analysis = analysis_result.get('vocabulary_analysis', {})
            coverage = vocab_analysis.get('vocabulary_coverage', {})
            
            if coverage:
                csv_data = []
                for book_name, data in coverage.items():
                    csv_data.append({
                        'å˜èªå¸³': book_name,
                        'èªå½™ã‚«ãƒãƒ¬ãƒƒã‚¸ç‡(%)': data.get('vocabulary_coverage_rate', 0),
                        'å˜èªå¸³ä½¿ç”¨ç‡(%)': data.get('vocabulary_utilization_rate', 0),
                        'ä¸€è‡´èªæ•°': data.get('matched_words_count', 0),
                        'å˜èªå¸³ç·èªæ•°': data.get('target_total_words', 0)
                    })
                
                df = pd.DataFrame(csv_data)
                df.to_csv(output_path.with_suffix('.csv'), index=False, encoding='utf-8-sig')
                
                logger.info(f"CSVãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆã—ã¾ã—ãŸ: {output_path.with_suffix('.csv')}")
                return True
            else:
                logger.warning("CSVå‡ºåŠ›ç”¨ã®ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™")
                return False
                
        except Exception as e:
            logger.error(f"CSVãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    def _generate_text_report(self, analysis_result: Dict, output_path: Path) -> bool:
        """ãƒ†ã‚­ã‚¹ãƒˆãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ"""
        try:
            assessment = analysis_result.get('comprehensive_assessment', {})
            report = analysis_result.get('integrated_report', {})
            
            text_content = f"""
{self.config.title}
{'=' * len(self.config.title)}

ç”Ÿæˆæ—¥æ™‚: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
ä½œæˆè€…: {self.config.author}

ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼
------------------
ç·åˆé›£æ˜“åº¦: {assessment.get('difficulty_level', 'ä¸æ˜')}
èª­è§£ãƒ¬ãƒ™ãƒ«: {assessment.get('reading_level', 'ä¸æ˜')}
æ¨å®šèª­è§£æ™‚é–“: {assessment.get('estimated_reading_time_minutes', 0)}åˆ†
ç·åˆã‚¹ã‚³ã‚¢: {assessment.get('overall_difficulty_score', 0):.1f}

ä¸»è¦ãªå­¦ç¿’èª²é¡Œ:
{self._format_challenges_text(report.get('executive_summary', {}).get('key_challenges', []))}

å­¦ç¿’æ¨å¥¨äº‹é …:
{self._format_recommendations_text(report.get('study_recommendations', {}))}

è©³ç´°åˆ†æçµæœ:
{self._format_detailed_analysis_text(analysis_result)}
"""
            
            with open(output_path.with_suffix('.txt'), 'w', encoding='utf-8') as f:
                f.write(text_content)
            
            logger.info(f"ãƒ†ã‚­ã‚¹ãƒˆãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆã—ã¾ã—ãŸ: {output_path.with_suffix('.txt')}")
            return True
            
        except Exception as e:
            logger.error(f"ãƒ†ã‚­ã‚¹ãƒˆãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    def _format_challenges_text(self, challenges: List[str]) -> str:
        """èª²é¡Œãƒªã‚¹ãƒˆã®ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        if not challenges:
            return "ç‰¹ã«å¤§ããªèª²é¡Œã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚"
        
        return '\\n'.join(f"  - {challenge}" for challenge in challenges)
    
    def _format_recommendations_text(self, recommendations: Dict) -> str:
        """æ¨å¥¨äº‹é …ã®ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        if not recommendations:
            return "æ¨å¥¨äº‹é …ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"
        
        formatted = ""
        for area, items in recommendations.items():
            if items:
                area_name = {
                    'priority_areas': 'å„ªå…ˆå­¦ç¿’åˆ†é‡',
                    'vocabulary_study': 'èªå½™å­¦ç¿’',
                    'grammar_study': 'æ–‡æ³•å­¦ç¿’',
                    'reading_strategy': 'èª­è§£æˆ¦ç•¥'
                }.get(area, area)
                
                formatted += f"\\n{area_name}:\\n"
                formatted += '\\n'.join(f"  - {item}" for item in items)
                formatted += "\\n"
        
        return formatted
    
    def _format_detailed_analysis_text(self, analysis_result: Dict) -> str:
        """è©³ç´°åˆ†æã®ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        sections = []
        
        # èªå½™åˆ†æ
        vocab_analysis = analysis_result.get('vocabulary_analysis', {})
        if vocab_analysis:
            sections.append("èªå½™åˆ†æ:")
            text_stats = vocab_analysis.get('text_statistics', {})
            sections.append(f"  - æŠ½å‡ºç·å˜èªæ•°: {text_stats.get('total_words', 0):,}")
            sections.append(f"  - ãƒ¦ãƒ‹ãƒ¼ã‚¯å˜èªæ•°: {text_stats.get('unique_words', 0):,}")
            
            summary = vocab_analysis.get('summary', {})
            best_book = summary.get('best_coverage_book', {})
            if best_book:
                sections.append(f"  - æœ€é©å˜èªå¸³: {best_book.get('name', 'ä¸æ˜')}")
        
        # æ–‡æ³•åˆ†æ
        grammar_analysis = analysis_result.get('grammar_analysis', {})
        if grammar_analysis:
            sections.append("\\næ–‡æ³•åˆ†æ:")
            summary = grammar_analysis.get('summary', {})
            sections.append(f"  - æ–‡æ³•é …ç›®æ•°: {summary.get('total_grammar_items', 0)}")
            sections.append(f"  - æ–‡æ³•å¯†åº¦: {summary.get('grammar_density', 0):.1f}%")
            sections.append(f"  - è¤‡é›‘åº¦ãƒ¬ãƒ™ãƒ«: {summary.get('complexity_level', 'ä¸æ˜')}")
        
        # æ–‡æ§‹é€ åˆ†æ
        sentence_analysis = analysis_result.get('sentence_analysis', {})
        if sentence_analysis:
            sections.append("\\næ–‡æ§‹é€ åˆ†æ:")
            basic_stats = sentence_analysis.get('basic_statistics', {})
            sections.append(f"  - ç·æ–‡æ•°: {basic_stats.get('total_sentences', 0)}")
            sections.append(f"  - å¹³å‡æ–‡é•·: {basic_stats.get('avg_words_per_sentence', 0):.1f}èª")
            
            readability = sentence_analysis.get('readability_scores', {})
            sections.append(f"  - èª­ã¿ã‚„ã™ã•: {readability.get('reading_level', 'ä¸æ˜')}")
        
        return '\\n'.join(sections)

def main():
    """ãƒ†ã‚¹ãƒˆç”¨ãƒ¡ã‚¤ãƒ³é–¢æ•°"""
    # ã‚µãƒ³ãƒ—ãƒ«åˆ†æçµæœ
    sample_result = {
        'metadata': {
            'analysis_timestamp': datetime.datetime.now().isoformat(),
            'text_length': 1000
        },
        'comprehensive_assessment': {
            'difficulty_level': 'ä¸­',
            'reading_level': 'é«˜æ ¡æ¨™æº–ãƒ¬ãƒ™ãƒ«',
            'estimated_reading_time_minutes': 5,
            'overall_difficulty_score': 65.5
        },
        'integrated_report': {
            'executive_summary': {
                'key_challenges': [
                    'èªå½™åŠ›ã‚„ã‚„ä¸è¶³: ä¸­ç´šå˜èªã®å¼·åŒ–ãŒå¿…è¦',
                    'æ–‡æ³•æ§‹é€ ãŒè¤‡é›‘: ä¸­ç´šãƒ¬ãƒ™ãƒ«ã®æ–‡æ³•é …ç›®ãŒå¤šç”¨'
                ]
            },
            'study_recommendations': {
                'vocabulary_study': ['Target 1900ã§ã®å­¦ç¿’', 'èªæ ¹å­¦ç¿’'],
                'grammar_study': ['é–¢ä¿‚ä»£åè©ã®å¾©ç¿’', 'å®Œäº†å½¢ã®ç·´ç¿’']
            }
        }
    }
    
    # HTMLãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆãƒ†ã‚¹ãƒˆ
    config = ReportConfig(format="html")
    generator = ReportGenerator(config)
    
    output_path = "test_report"
    success = generator.generate_comprehensive_report(sample_result, output_path)
    
    if success:
        print("ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆãƒ†ã‚¹ãƒˆãŒæˆåŠŸã—ã¾ã—ãŸ")
    else:
        print("ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã—ã¾ã—ãŸ")

if __name__ == "__main__":
    main()